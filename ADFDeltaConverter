package com.lss;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import java.util.*;

import java.util.*;

public class AdfDeltaConverter {

    public static Map<String, Object> deltaToAdf(Map<String, Object> delta) {
        List<Map<String, Object>> ops = (List<Map<String, Object>>) delta.get("ops");
        Map<String, Object> adf = new HashMap<String, Object>();
        adf.put("version", 1);
        adf.put("type", "doc");
        List<Map<String, Object>> content = new ArrayList<Map<String, Object>>();

        String currentListType = null; // "ordered" or "bullet"
        List<Map<String, Object>> listBuffer = new ArrayList<Map<String, Object>>();
        StringBuilder lineBuffer = new StringBuilder();

        for (int i = 0; i < ops.size(); i++) {
            Map<String, Object> op = ops.get(i);
            Object insertObj = op.get("insert");
            Map<String, Object> attrs = (Map<String, Object>) op.get("attributes");

            if (insertObj instanceof String) {
                String s = (String) insertObj;
                // split keeping trailing empty
                String[] parts = s.split("\n", -1);
                for (int p = 0; p < parts.length; p++) {
                    String part = parts[p];
                    lineBuffer.append(part);
                    boolean isLastPart = (p == parts.length - 1);
                    boolean hasInternalNewline = (p < parts.length - 1);

                    if (hasInternalNewline) {
                        // finalize this internal line -> internal newlines usually have NO separate attrs
                        String lineText = lineBuffer.toString();
                        Map<String, Object> paragraph = makeParagraphNode(lineText);

                        // If current op itself has attrs that are line-level, apply them (rare).
                        Map<String, Object> lineAttrs = (attrs != null && attrs.containsKey("list")) ? attrs : null;

                        if (lineAttrs != null && lineAttrs.get("list") != null) {
                            String listType = String.valueOf(lineAttrs.get("list"));
                            if (currentListType == null) {
                                currentListType = listType;
                                listBuffer = new ArrayList<Map<String, Object>>();
                            }
                            if (!listType.equals(currentListType)) {
                                content.add(makeListNode(currentListType, listBuffer));
                                listBuffer = new ArrayList<Map<String, Object>>();
                                currentListType = listType;
                            }
                            listBuffer.add(makeListItem(paragraph));
                        } else {
                            if (currentListType != null && !listBuffer.isEmpty()) {
                                content.add(makeListNode(currentListType, listBuffer));
                                listBuffer = new ArrayList<Map<String, Object>>();
                                currentListType = null;
                            }
                            content.add(paragraph);
                        }

                        lineBuffer.setLength(0);
                    }

                    if (isLastPart) {
                        // This is the last part of this text op.
                        // It may be followed by a separate "\n" op that carries line attributes
                        if (i + 1 < ops.size()) {
                            Map<String, Object> nextOp = ops.get(i + 1);
                            Object nextInsert = nextOp.get("insert");
                            Map<String, Object> nextAttrs = (Map<String, Object>) nextOp.get("attributes");
                            if (nextInsert instanceof String && "\n".equals(nextInsert) && nextAttrs != null && !nextAttrs.isEmpty()) {
                                // The standalone newline applies to this last part -> consume next op
                                String lineText = lineBuffer.toString();
                                Map<String, Object> paragraph = makeParagraphNode(lineText);

                                Map<String, Object> lineAttrs = nextAttrs;

                                if (lineAttrs.get("list") != null) {
                                    String listType = String.valueOf(lineAttrs.get("list"));
                                    if (currentListType == null) {
                                        currentListType = listType;
                                        listBuffer = new ArrayList<Map<String, Object>>();
                                    }
                                    if (!listType.equals(currentListType)) {
                                        content.add(makeListNode(currentListType, listBuffer));
                                        listBuffer = new ArrayList<Map<String, Object>>();
                                        currentListType = listType;
                                    }
                                    listBuffer.add(makeListItem(paragraph));
                                } else {
                                    if (currentListType != null && !listBuffer.isEmpty()) {
                                        content.add(makeListNode(currentListType, listBuffer));
                                        listBuffer = new ArrayList<Map<String, Object>>();
                                        currentListType = null;
                                    }
                                    content.add(paragraph);
                                }

                                lineBuffer.setLength(0);
                                // consume the next op (the standalone newline)
                                i++;
                                // done handling last part
                                continue;
                            }
                        }

                        // Else: no standalone newline with attrs after this part.
                        // Do not finalize yet unless this text op itself ended with a newline (it didn't),
                        // so we leave lineBuffer as is to accumulate more text or next ops.
                        // However if this text op itself ended with a trailing empty string (i.e., s ended with '\n')
                        // then parts will have trailing empty and we'd have handled it as hasInternalNewline earlier.
                    }
                }
            } else if (insertObj instanceof Map) {
                // embedded object like image: treat as a mediaSingle paragraph
                Map<String, Object> embed = (Map<String, Object>) insertObj;
                if (embed.containsKey("image")) {
                    String url = String.valueOf(embed.get("image"));
                    Map<String, Object> mediaSingle = makeMediaSingleNode(url);
                    // flush any pending lineBuffer as paragraph
                    if (lineBuffer.length() > 0) {
                        Map<String, Object> paragraph = makeParagraphNode(lineBuffer.toString());
                        if (currentListType != null && !listBuffer.isEmpty()) {
                            content.add(makeListNode(currentListType, listBuffer));
                            listBuffer = new ArrayList<Map<String, Object>>();
                            currentListType = null;
                        }
                        content.add(paragraph);
                        lineBuffer.setLength(0);
                    }
                    // flush any pending list
                    if (currentListType != null && !listBuffer.isEmpty()) {
                        content.add(makeListNode(currentListType, listBuffer));
                        listBuffer = new ArrayList<Map<String, Object>>();
                        currentListType = null;
                    }
                    content.add(mediaSingle);
                }
            }
        }

        // If there's any remaining lineBuffer (text without trailing newline), treat as paragraph.
        if (lineBuffer.length() > 0) {
            Map<String, Object> paragraph = makeParagraphNode(lineBuffer.toString());
            if (currentListType != null && !listBuffer.isEmpty()) {
                content.add(makeListNode(currentListType, listBuffer));
                listBuffer = new ArrayList<Map<String, Object>>();
                currentListType = null;
            }
            content.add(paragraph);
            lineBuffer.setLength(0);
        }

        // flush any remaining list
        if (currentListType != null && !listBuffer.isEmpty()) {
            content.add(makeListNode(currentListType, listBuffer));
        }

        adf.put("content", content);
        return adf;
    }

    private static Map<String, Object> makeParagraphNode(String text) {
        Map<String, Object> paragraph = new HashMap<String, Object>();
        paragraph.put("type", "paragraph");
        List<Map<String, Object>> inner = new ArrayList<Map<String, Object>>();
        Map<String, Object> textNode = new HashMap<String, Object>();
        textNode.put("type", "text");
        textNode.put("text", text);
        inner.add(textNode);
        paragraph.put("content", inner);
        return paragraph;
    }

    private static Map<String, Object> makeListItem(Map<String, Object> paragraph) {
        Map<String, Object> item = new HashMap<String, Object>();
        item.put("type", "listItem");
        List<Map<String, Object>> content = new ArrayList<Map<String, Object>>();
        content.add(paragraph);
        item.put("content", content);
        return item;
    }

    private static Map<String, Object> makeListNode(String listType, List<Map<String, Object>> items) {
        Map<String, Object> node = new HashMap<String, Object>();
        if ("ordered".equals(listType)) {
            node.put("type", "orderedList");
            Map<String, Object> attrs = new HashMap<String, Object>();
            attrs.put("order", 1);
            node.put("attrs", attrs);
        } else {
            node.put("type", "bulletList");
        }
        node.put("content", items);
        return node;
    }

    private static Map<String, Object> makeMediaSingleNode(String imageUrl) {
        Map<String, Object> mediaSingle = new HashMap<String, Object>();
        mediaSingle.put("type", "mediaSingle");
        Map<String, Object> attrs = new HashMap<String, Object>();
        attrs.put("layout", "center");
        mediaSingle.put("attrs", attrs);
        List<Map<String, Object>> content = new ArrayList<Map<String, Object>>();
        Map<String, Object> media = new HashMap<String, Object>();
        media.put("type", "media");
        Map<String, Object> mediaAttrs = new HashMap<String, Object>();
        mediaAttrs.put("type", "external");
        mediaAttrs.put("url", imageUrl);
        media.put("attrs", mediaAttrs);
        content.add(media);
        mediaSingle.put("content", content);
        return mediaSingle;
    }

    public static Map<String, Object> adfToDelta(Map<String, Object> adf) {
        List<Map<String, Object>> content = (List<Map<String, Object>>) adf.get("content");
        List<Map<String, Object>> ops = new ArrayList<Map<String, Object>>();

        for (Map<String, Object> node : content) {
            String type = String.valueOf(node.get("type"));
            if ("paragraph".equals(type)) {
                List<Map<String, Object>> inner = (List<Map<String, Object>>) node.get("content");
                StringBuilder sb = new StringBuilder();
                for (Map<String, Object> t : inner) {
                    if ("text".equals(String.valueOf(t.get("type")))) {
                        sb.append(String.valueOf(t.get("text")));
                    }
                }
                Map<String, Object> op = new HashMap<String, Object>();
                op.put("insert", sb.toString() + "\n");
                ops.add(op);
            } else if ("orderedList".equals(type) || "bulletList".equals(type)) {
                String listType = "orderedList".equals(type) ? "ordered" : "bullet";
                List<Map<String, Object>> items = (List<Map<String, Object>>) node.get("content");
                for (Map<String, Object> item : items) {
                    List<Map<String, Object>> itemContent = (List<Map<String, Object>>) item.get("content");
                    if (itemContent != null && !itemContent.isEmpty()) {
                        Map<String, Object> paragraph = itemContent.get(0);
                        List<Map<String, Object>> inner = (List<Map<String, Object>>) paragraph.get("content");
                        StringBuilder sb = new StringBuilder();
                        for (Map<String, Object> t : inner) {
                            if ("text".equals(String.valueOf(t.get("type")))) {
                                sb.append(String.valueOf(t.get("text")));
                            }
                        }
                        Map<String, Object> opText = new HashMap<String, Object>();
                        opText.put("insert", sb.toString());
                        ops.add(opText);
                        Map<String, Object> newline = new HashMap<String, Object>();
                        newline.put("insert", "\n");
                        Map<String, Object> attr = new HashMap<String, Object>();
                        attr.put("list", listType);
                        newline.put("attributes", attr);
                        ops.add(newline);
                    }
                }
            } else if ("mediaSingle".equals(type) || "mediaGroup".equals(type)) {
                List<Map<String, Object>> medias = (List<Map<String, Object>>) node.get("content");
                for (Map<String, Object> media : medias) {
                    Map<String, Object> attrs = (Map<String, Object>) media.get("attrs");
                    if (attrs != null) {
                        String url = (String) attrs.get("url");
                        if (url == null && attrs.get("id") != null) {
                            // hypothetical attachment URL construction
                            url = "/rest/api/3/attachments/" + attrs.get("id") + "/data";
                        }
                        Map<String, Object> embed = new HashMap<String, Object>();
                        Map<String, Object> insert = new HashMap<String, Object>();
                        insert.put("image", url);
                        embed.put("insert", insert);
                        ops.add(embed);
                    }
                }
            }
        }

        Map<String, Object> delta = new HashMap<String, Object>();
        delta.put("ops", ops);
        return delta;
    }

    // simple JSON serializer for Maps/Lists/Strings/Numbers/Booleans/null
    private static String toJson(Object obj) {
        if (obj == null) return "null";
        if (obj instanceof String) return '\"' + escape((String) obj) + '\"';
        if (obj instanceof Number || obj instanceof Boolean) return String.valueOf(obj);
        if (obj instanceof Map) {
            StringBuilder sb = new StringBuilder();
            sb.append('{');
            Map<?, ?> m = (Map<?, ?>) obj;
            boolean first = true;
            for (Map.Entry<?, ?> e : m.entrySet()) {
                if (!first) sb.append(',');
                first = false;
                sb.append(toJson(String.valueOf(e.getKey()))).append(':').append(toJson(e.getValue()));
            }
            sb.append('}');
            return sb.toString();
        }
        if (obj instanceof List) {
            StringBuilder sb = new StringBuilder();
            sb.append('[');
            List<?> l = (List<?>) obj;
            for (int i = 0; i < l.size(); i++) {
                if (i > 0) sb.append(',');
                sb.append(toJson(l.get(i)));
            }
            sb.append(']');
            return sb.toString();
        }
        // fallback
        return '\"' + escape(String.valueOf(obj)) + '\"';
    }

    private static String escape(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            switch (c) {
                case '\\': sb.append("\\\\"); break;
                case '\"': sb.append("\\\""); break;
                case '\b': sb.append("\\b"); break;
                case '\f': sb.append("\\f"); break;
                case '\n': sb.append("\\n"); break;
                case '\r': sb.append("\\r"); break;
                case '\t': sb.append("\\t"); break;
                default:
                    if (c < 32) {
                        sb.append(String.format("\\u%04x", (int) c));
                    } else {
                        sb.append(c);
                    }
            }
        }
        return sb.toString();
    }

    // Test using the provided data structures, print JSON
    public static void main(String[] args) {
        List<Map<String, Object>> ops = new ArrayList<Map<String, Object>>();

        // Build ops according to user's provided delta
        ops.add(new HashMap<String, Object>() {{ put("insert", "aaa\nAAA"); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "\n"); put("attributes", new HashMap<String, Object>() {{ put("list", "ordered"); }}); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "BBB"); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "\n"); put("attributes", new HashMap<String, Object>() {{ put("list", "ordered"); }}); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "bbb\nAAA"); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "\n"); put("attributes", new HashMap<String, Object>() {{ put("list", "bullet"); }}); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "BBB"); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "\n"); put("attributes", new HashMap<String, Object>() {{ put("list", "bullet"); }}); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "CCC"); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "\n"); put("attributes", new HashMap<String, Object>() {{ put("list", "bullet"); }}); }});
        ops.add(new HashMap<String, Object>() {{ put("insert", "ccc\n"); }});

        Map<String, Object> delta = new HashMap<String, Object>();
        delta.put("ops", ops);

        Map<String, Object> adf = deltaToAdf(delta);
        System.out.println(toJson(adf));

        Map<String, Object> delta2 = adfToDelta(adf);
        System.out.println(toJson(delta2));

        Map<String, Object> adfBack = deltaToAdf(delta2);
        System.out.println(toJson(adfBack));
    }
}
